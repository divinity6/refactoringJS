## 코드에서 나는 악취

    
 리팩터링을 언제해야하는가?

---

### 기이한 이름( Mysterious Name )

- 코드는 단순 명료하게 작성해야 한다


- 이름만 보고도 어떻게 작동하는지 명확하게 지어야 한다
  - ( 이름 짓기 , 캐시 무효화가 제일 어려운 컴퓨터 공학 )


- 이름만 잘지어도 문맥을 파악하느라 헤메는 시간을 절약할 수 있다


- 마땅한 이름이 떠오르지 않는다 <span style="color:#ffb300"> 설계에 문제가 있을 가능성이 크다 </span>


- 이럴 경우,
  - **함수 선언 바꾸기**( 6.5 절 )
  - **변수 이름 바꾸기**( 6.7 절 )
  - **필드 이름 바꾸기**( 9.2 절 )

---

### 중복 코드( Duplicated Code )

- 비슷하게 생긴 코드가 있다면 비슷한 부분을 모아 함수 추출하기를 더 쉽게 할 수 있는지 살펴봐야 한다

- 이럴 경우
  - **함수 추출하기**( 6.1절 )
  - **문장 슬라이드하기**( 8.6 절 )
  - **메서드 올리기**( 12.1 절 )

---

### <span style="color:#ffb300">긴 함수( Long Function )</span>

- 짧은 함수들은 <span style="color:#ffb300">끊임없이 위임하는 방식</span>으로 설계되어 있다


- 간접 호출( indirection )의 효과 는 코드를 이해하고, 공유하고 선택하기 쉽게 해준다


- 짧은 함수로 구성된 코드를 이해하기 쉽게 맨드는 방법은 <span style="color:#ffb300">좋은 이름</span>이다


- 함수이름은 <span style="color:#ffb300">동작 방식이 아닌 의도( intention )</span>가 드러나도록 짓는다
    - 즉, <span style="color:#ffb300">함수 이름에 코드의 목적이 드러나야 한다</span>


- 무엇을 하는지 코드가 설명해주지 못할수록 함수로 맨드는게 유리하다


- 매개변수와 임시변수가 너무많다면?
  - **임시변수를 질의 함수로 바꾸기**( 7.4 절 )
  - **매개변수 객체 만들기**( 6.7 절 )
  - **객체 통째로 넘기기**( 11.4 절 )
  - **함수를 명령으로 바꾸기**( 11.9 절 )


- 조건문이나 반복문일 경우에는?
  - **조건문 분해하기**( 10.1 절 )
  - **함수 추출하기**( 6.1 절 )
  - **조건부 로직을 다형성으로 바꾸기**( 10.4 절 )
  - **반복문 쪼개기**( 8.7절 )


- 코드가 <span style="color:#ffb300">단 한줄이어도 설명할 주석이 필요하다면 함수로 추출하는 것</span>이 좋다

---

### 긴 매개변수 목록( Long Parameter List )

- 프로그람을 처음배울때는 전역 데이터가 늘어나는 것을 막기 위해 모조리 매개변수로 넘겼다
- 그러나 매개변수 목록이 길어지면 그 자체로 이해하기 어려울때가 많다

- 이럴 경우,
  - **매개변수를 질의 함수로 바꾸기**( 11.5 절 )
  - **객체 통째로 넘기기**( 11.4 절 )
  - **매개변수 객체 만들기**( 6.8 절 )
  - **플래그 인수 제거하기**( 11.3 절 )
  - **여러 함수를 클래스로 묶기**( 6.9 절 )


- <span style="color:#ffb300">클래스는 매개변수 목록을 줄이는데 효과적인 수단으로도 사용할 수 있다</span>

---

### 전역 데이터( Global Data )

- 전역 데이터는 코드베이스 어디서든 건드릴 수 있고, 누가 값을 바꿨는지 찾아낼 메커니즘이 없는것이 문제다
  - 따라서, 한쪽을 바꾸었는데, 멀리떨어진 어떤 코드가 변경되는 미친 현상이 발생한다


- 이를 방지하려면,
  - **변수 캡슐화하기**( 6.6 절 )


- 전역 데이터가 가변( mutable )이라면 다루기 까다롭다
- 전역 데이터가 아주 조금만 있더라도 캡슐화를 해야한다

---

### 가변 데이터( Mutable Data )

- 데이터를 변경해버리면 다른곳에서 예상치 못한 버그를 마주할 때가 있다.
  - 따라서, 함수형 프로그라밍에서는 복사본을 만들어서 사용하는 개념을 기본으로 삼는다


- 불변성이 주는 장점은 많기 때문에, 데이터 수정에 따른 위험을 줄이는 방법은
  - **변수 캡슐화하기**( 6.6 절 )
  - **변수 쪼개기**( 9.1 절 )
  - **문장 슬라이드하기**( 8.6 절 )
  - **함수 추출하기**( 6.1 절 )
  - **질의 함수와 변경 함수 분리하기**( 11.1 절 )
  - **세터 제거하기**( 11.1 절 )
  - **파생 변수를 질의 함수로 바꾸기**( 9.3 절 )
  - **여러 함수를 클래스로 묶기**( 6.9 절 )
  - **여러 함수를 변환 함수로 묶기**( 1.10 절 )
  - **참조를 값으로 바꾸기**( 9.4 절 )
  

- 가변 데이터가 단 몇줄에서만 유효범위를 가진다고 해도 나중에 코드가 확장되면 문제가 발생할 여지가 존재한다

---

### 뒤엉킨 변경( Divergent Change )

- 뒤엉킨 변경은 단일 책임 원칙( Single Responsibility Principle : SRP )이 제대로 지켜지지 않을 경우 나타난다


- 새로운 기능이 추가되거나, 변경될때마다 관련된 많은 함수를 바꿔야 한다면, 뒤엉킨 변경이다


- 독립모듈로 분리해, 무언가를 수정할때 해당 맥락의 코드만 이해해도 괜찮게 작성한다


- 해당 방법으로는
  - **단계 쪼개기**( 6.11 절 )
  - **함수 옮기기**( 8.1 절 )
  - **함수 추출하기**( 6.1 절 )
  - **클래스 추출하기**( 7.5 절 )


---

### 산탄총 수술( Shotgun Surgery )


- 코드를 변경할 때마다 자잘하게 수정해야하는 클래스가 많을 경우 풍긴다


- 변경해야할 부분이 코드 전반에 퍼져있다면 찾기도 어렵고 꼭 수정해야할 곳은 지나치기 쉽다


- 이럴때는,
  - **함수 옮기기**( 8.1 절 )
  - **필드 옮기기**( 8.2 절 )
  - **여러 함수를 클래스로 묶기**( 6.9 절 )
  - **여러 함수를 변환 함수로 묶기**( 6.10 절 )
  - **단계 쪼개기**( 6.11 절 )


- 어설프게 분리된 로직일 경우에는
  - **함수 인라인하기**( 6.2 절 )
  - **클래스 인라인하기**( 7.6 절 )

    
- 메서드나 클래스가 비대해 지지만 나중에 추출하기 리팩터링으로 더 좋은 형태로 분리할 수 있다
  - ( 작은 함수와 클래스에 집착하지만, 코드를 재구성하는 중간 과정에서 큰 덩어리로 뭉치는데는 개의치 않는다 )


---

### 기능 편애( Feature Envy )

- 프로그람을 모듈화시 코드를 여러 영역으로 나누고 영역안의 상호작용은 늘리고, 영역 사이에서 이뤄지는 상호작용은 줄이는데 주력한다


- 기능 편애는 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을경우 풍긴다


- 함수가 실행될때, 외부 메서드를 호출하도록 작성된 함수라면
  - **함수 옮기기**( 8.1 절 )
  - **함수 추출하기**( 6.1 절 )
  - **함수 옮기기**( 8.1 절 )


- 어디로 옮겨야할지 명확하게 드러나지 않을 경우, 가장 많은 데이터를 포함한 모듈로 옮긴다


- 그러나 이런 규칙을 거스르는 복잡한 패턴인,
  - 전략 패턴( Strategy Pattern )
  - 방문자 패턴( Visitor Pattern )
  - 자기 위임( Self-Delegation )


- 이럴 경우, 데이터를 다루는 코드를 한 곳에서 변경할 수 있도록 옮긴다
  - 동작 코드를 각각의 클래스로 격리( 간접 호출의 증가 )

---

### 데이터 뭉치( Data Clumps )

- 데이터 뭉치들을 묶어서 하나의 보금자리를 만들어줘야한다. 따라서,
  - **클래스 추출하기**( 7.5 절 )
  - **매개변수 객체 만들기**( 6.8 절 )
  - **객체 통째로 넘기기**( 11.4 절 )


- 데이터 뭉치인지 판별하기 위해서는 값하나를 삭제 했을 경우, 나머지 데이터만으로는 의미가 없다면, 새로운 객체로 맨든다

---

### 기본형 집착( Primitive Obsession )

- 대부분의 프로그라밍 언어는 다양한 기본형( Primitive type )을 제공한다


- 많은 프로그라머는 문제에 딱 맞는  <span style="color:#ffb300">기초 타입( 화폐, 좌표, 구간등 )을 직접 정의</span>하기 꺼려하는 사람들이 많다


- 이럴 경우,
  - **기본형을 객체로 바꾸기**( 7.3 절 )
  - **타입 코드를 서브클래스로 바꾸기**( 12.6 절 )
  - **조건부 로직을 다형성으로 바꾸기**( 10.4 절 )


- 기본형 그룹이 데이터 뭉치일 경우,
  - **클래스 추출하기**( 7.5 절 )
  - **매개변수 객체 만들기**( 6.8 절 )

---

### 반복되는 switch 문( Repeated Switches )

- switch 문을
  - **조건부 로직을 다형성으로 바꾸기**( 10.4 절 )


- 로 바꿔야 한다고 생각하기도 하지만,


- 단순히 switch 문을 사용했다고 바꾸는 것은 아니다


- 그러나, 똑같은 조건부 로직( switch/case or if/else )이 여러곳에서 반복되는 경우

---

### 반복문( Loops )

- 반복문은 핵심 프로그라밍 요소지만, 이제는 너무 좋지 못한존재가 되었다


- 지금은 일급 함수( first-class function )를 지원하는 언어가 많아졌기 때문에
  - **반복문을 파이프라인으로 바꾸기**( 8.8 절 )
  - filter 나 map 등 을 이용해 연산을 하면 각 코드에서 원소가 어떻게 처리되는지 볼 수 있다

---

### 성의 없는 요소( Lazy Element )

- 코드의 구조를 잡을때 프로그람 요소( 함수, 메서드, 클래스 , 인터페이스 등 )를 이용한다


- 그러나 구조가 필요 없을때도 있다
  - 본문 코드를 그대로 쓰는것과 진배 없는 코드
  - 어떤 메서드를 추가할 생각이었지만, 사정때문에 그렇지 못한 경우
  - 풍성했던 클래스가 리팩터링을 거치면서 역할이 줄어든 코드


- 이럴때는,
  - **함수 인라인하기**( 6.2 절 )
  - **클래스 인라인하기**( 7.6 절 )
  - **계층 합치기**( 12.9 절 )

---

### 추측성 일반화( Speculative Generality )

- 나중에 필요할 거야 라는 생각으로 당장은 필요 없는 모든 종류의 후킹( hooking ) 포인트와 특이 케이스 처리 로직 코드


- 이 결과는 이해하거나 관리하기 어려워진 코드가 된다( 미래를 대비하기 위한 코드였지만... )


- 당장 걸리적 거리는 코드는 아래의 방법으로 처리해야한다
  - **계층 합치기**( 12.9 절 )
  - **함수 인라인하기**( 6.2 절 )
  - **클래스 인라인하기**( 7.6 절 )
  - **함수 선언 바꾸기**( 6.5 절 )
  - **죽은 코드 제거하기**( 8.9 절 )


- 미래에 필요할 거라 예상했지만, 한번도 사용한적 없는 매개변수등을 제거할 경우...

---

### 임시 필드( Temporary Field )

- 특정 상황에서만 값이 설정되는 필드를 가진 클래스일 경우
  - ( 일반적으로 객체를 가져올때는 모든 필드가 채워져 있으리라 기대한다 )
  - 이런 경우 코드를 이해하기 어렵고, 필드가 존재하는 이유를 파악해야한다


- 이럴 경우
  - **클래스 추출하기**( 7.5 절 )
  - **함수 옮기기**( 8.1 절 )
  - **특이 케이스 추가하기**( 10.5 절 )

---

### <span style="color:#ffb300">메시지 체인( Message Chains )</span>

*내가 습관적으로 많이 사용하는 것 : 아래처럼 분리해야함!

- 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 것
  - 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드등


- 클라이언트가 객체 내비게이션 구조에 종속되었음을 의미할때( 게터가 꼬리를 물고 이어지거나, 임시 변수들이 줄줄이 나열되는 코드 )
  - **위임 숨기기**( 7.7 절 )
  - **함수 추출하기**( 6.1 절 )
  - **함수 옮기기**( 8.1 절 )

> ***위임 숨기기** :
> 
> 메시지 체인의 전형적인 예
> 
> ````javascript
>    managerName = aPerson.department.manager.name;
> ````
> 
> ---
> 
> 체인을 구성하는 모든 객체에 위임 숨기기를 적용
> 
> --> 부서장 이름을 반환하는 메서드
> 
> ----> 사람 클래스에 추가 or 부서 클래스에 추가 or 부서장을 얻는 메서드를 사람 클래스에 추가 등
>
> ````javascript
>    managerName = aPerson.department.managerName; // 관리자 객체( manager )의 존재를 숨김 
> 
>    managerName = aPerson.manager.name; // 부서 객체( department )의 존재를 숨김 
> 
>    managerName = aPerson.managerName; // 부서 객체( department )와 관리자 객체( manager )의 존재를 모두 숨김
> ````
> 
> ---
> 
> 사용예)
>
> ````javascript
>    managerName = aPerson.department.manager.name;
> 
>    report = `${ managerName }께 ${ aPerson.name } 님의 작업 로그 ...`
>   
>    console.log( report );
> ````
> 
> 이럴 경우 보고서 생성 로직을 함수로 추출 후, 모듈로 감추면 체인의 존재가 감춰진다
>
> ````javascript
>    console.log( reportAutoGenerator.report( aPerson ) );
> ````

- 게터가 꼬리를 물고 이어지거나, 임시 변수들이 줄줄이 나열되는 코드는 중개자( 3.18 절 ) 코드가 되어버리기 쉽다


- 따라서, 최종 결과 객체가 어떻게 쓰이는지부터 살펴보는것이 좋다

---

### 중개자( Middle Man )

- 객체의 대표적인 기능 :


  - 캡슐화( encapsulation ) : 외부로부터 세부사항을 숨겨주는 기능


  - 캡슐화 하는 과중에서 위임( delegation )이 자주 활용된다


  - 위임이 지나치면 문제가 된다( 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있을 경우 )


- 이럴 때,
  - **중개자 제거하기**( 7.8 절 )
  - **함수 인라인하기**( 6.2 절 )


- 등을 활용하여 실제 일을하는 객체와 직접 소통 후, 호출하는쪽으로 인라인할 수 있으면 인라인 하자

---

### 내부자 거래( Insider Trading )

- 모듈 사이의 데이터 거래가 많으면 결합도( coupling )가 높아진다


- 어쩔 수 없이 거래가 이루어질 수 밖에 없지만, 그 양을 최소로 줄이고 모두 투명하게 처리해야 한다


- 은밀히 데이터를 주고받는 모듈이 있다면
  - **함수 옮기기**( 8.1 절 )
  - **필드 옮기기**( 8.2 절 )
  

- 여러 모듈이 같은 관심사를 공유한다면, 공통 부분을 정식으로 처리하는 제 3의 모듈을 맨들거나,
  - **위임 숨기기**( 7.7 절 )


- 상속 구조에서는 부모 자식 사이에 결탁이 생길 때가 있다.( 부모가 공개하고 싶은 것 이상으로 알려할 경우 )
  - **서브클래스를 위임으로 바꾸기**( 12.10 절 )
  - **슈퍼클래스를 위임으로 바꾸기**( 12.11 절 )

---

### 거대한 클래스( Large Class )

- 한 클래스가 너무 많은 일을 할 경우 필드수가 상당히 늘어나고, 클래스에 필드가 많으면 중복 코드가 생기기 쉽다

- 이럴 경우 필드를 따로묶는데,
  - **클래스 추출하기**( 7.5 절 )


- 같은 컴포넌트에 모아두는 것이 합당해보이는 필드들을 묶거나,


- 한 클래스 안에서 접두어, 접미어가 같은 필드들을 묶는다


- 이렇게 분리할 컴포넌트를 원래 클래스와 상속 관계로 맨들어야 할 경우에는( 클래스를 추출하는 것이 아닌 ),
  - **슈퍼클래스 추출하기**( 12.8 절 )
  - **타입 코드를 서브클래스로 바꾸기**( 12.6 절 )


- 필드가 너무 많은 클래스 처럼, 코드량이 너무 많은 클래스도 중복 코드와 혼동을 일으킬 여지가 크다


- ( 제일 좋은 방법은 클래스 내에서 자체적으로 중복을 제거하는 것 )


- 그외의 방법으로는...
  - **클래스 추출하기**( 7.5 절 )
  - **슈퍼클래스 추출하기**( 12.8 절 )
  - **타입코드를 서브클래스로 바꾸기**( 12.6 절 )

---

### 서로 다른 인터페이스의 대안 클래스들( Alternative Classes with Different Interfaces )

- 클래스의 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 것.


- 단, 교체하려면 인터페이스가 같아야하기 때문에 시그니처를 일치시키는데...
  - **함수 선언 바꾸기**( 6.5 절 )
  

- 그리고, 인터페이스가 같아질때까지 필요한 동작모두를...
  - **함수 옮기기**( 8.1 절 )
  

- 중복 코드가 생기면...
  - **슈퍼클래스 추출하기**( 12.8 절 )
  

---

### <span style="color:#ffb300">데이터 클래스( Data Class )</span>

<span style="color:#ffb300">데이터 클래스를 사용</span>할때는 반드시 참고하자 

- 데이터 필드와 게터/세터 메서드로만 구성된 클래스


- 데이터 저장 용도로만 쓰인다
  - ( 다른 클래스가 너무 깊이까지 함부로 다룰때가 많다 )


- 이런 클래스에 public 필드가 존재한다면
  - **레코드 캡슐화하기**( 7.1 절 )


- 변경하면 안되는 필드는,
  - **세터 제거하기**( 11.7 절 )


- 다른 클래스에서 데이터 클래스의 세터/게터를 사용하는 메서드를 찾아
  - **함수 옮기기**( 8.1 절 )


- 메서드를 통째로 옮기기 어렵다면
  - **함수 추출하기**( 6.1 절 )


- 데이터 클래스는 필요한 동작이 엉뚱한 곳에 정의돼 있다는 신호일 경우가 존재한다


- <span style="color:#ffb300">클라이언트 코드를 데이터 클래스로 옮기기만해도 대폭 개선</span>된다


- 불변 필드는 굳이 캡슐화할 필요가 없고, 불변 데이터로 나오는 정보는 게터를 통하지 않고 그냥 필드 자체를 공개해도 된다

---

### 상속 포기( Refused Bequest )

- 서브 클래스는 부모로부터 데이터와 메서드를 물려받는다. 그러나 부모의 유산을 원치 않거나 필요없다면? 유산 중 관심있는 몇개만 받고 끝내버리는 경우는?


- <span style="color:#ffb300">예전방식</span>의 해법은 같은 계층에 서브클래스를 하나 맨들고
  - **메서드 내리기**( 12.4 절 )
  - **필드 내리기**( 12.5 절 )


- 물려받지 않을 부모 코드를 새로 맨든 서브클래스로 넘긴다( 그러면 부모에는 공통된 부분만 남는다 )
  - 이렇게 하면 부모는 추상클래스만 남는다


- <span style="color:#ffb300">상속 포기를 진행할시 혼란과 문제가 생긴다면 예전 방식을 사용</span>한다


- 상속 포기 냄새는 서브클래스가 부모의 동작은 필요하지만, 인터페이스는 따르고 싶지 않을 경우
  - ( 구현을 따르지 않는 것은 이해할 수 있지만, 인터페이스를 따르지 않는 경우? )


- 이럴 경우 아래를 이용해 <span style="color:#ffb300">상속 메커니즘을 벗어나자</span>
  - **서브클래스를 위임으로 바꾸기**( 12.10 절 )
  - **슈퍼클래스를 위임으로 바꾸기**( 12.11 절 )
  

- 상속보단...위임...

---

### <span style="color:#ffb300">주석( Comments )</span>

- 주석은 악취가 아닌 향기가 풍기지만, <span style="color:#ffb300">탈취제처럼 사용</span>하면 문제가 된다
  - ( 주석이 장황하게 달린 원인은 주로 코드를 잘못 작성해서 그렇다 )
  

- <span style="color:#ffb300">주석이 많으면 온갖 악취를 풍기는 코드</span>가 나온다
  - 악취가 너무 심해 냄새를 걷어내고 보면, 상당량의 주석( 코드만 제대로 작성했다면 필요없을... )이 군더더기 였던 적이 많다


- 특정 코드 블록이 하는 일에 주석을 남기고 싶다면
  - **함수 추출하기**( 6.1 절 )


- 이미 추출되어 있는 함수임에도 설명이 필요하다면
  - **함수 선언 바꾸기**( 6.5 절 )


- 시스템이 동작하기 위한 선행조건을 명시하고 싶다면
  - **어서션 추가하기**( 10.6 절 )


> 주석을 남겨야겠다는 생각이 들면, <span style="color:#ffb300">가장 먼저 주석이 필요 없는 코드로 리팩터링</span>해본다

- 뭘 해야할지 모를 경우에는 주석을 달아두면 좋다.


- 현재 상황 뿐 아니라 확실하지 않은 상황에도 주석을 남긴다


- <span style="color:#ffb300">코드를 지금처럼 작성한 이유</span>를 설명하는 용도로 달 수 있다
  - ( 이런 정보는 코드를 수정해야 하는 개발자에게 도움이 된다 )
