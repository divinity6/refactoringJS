## 리팩터링 메모

### 기능
#### 다양한 연극을 외주로 받아서 공연하는 극단

- 공연 요청이 들어오면 연극의 장르 , 관객 규모를 기초로 비용을 책정한다
- 이 극단은 두가지 장르 비극( tragedy ), 희극( comedy )만 공연한다
- 공연료와는 별도로 포인트( volume credit )를 지급해서 다음번 의뢰시 공연로를 할인 받을 수 있다

---

- 연극 정보 : plays.json
- 공연료 청구서 : invoices.json
- 공연료 청구서를 출력하는 함수 : statement.mjs


#### statement 가 수행해야하는 로직

- **공연료**
- 비극 : 관객 30명까지는 40000 을 받고, 30명이상일 경우에는 1명당 1000원씩 추가
- 희극 : 
  - 공통 : 전체 관객수 관객 한명당 300원 추가
  - 관객 20명까지는 기본 30000 을 받음
  - 관객 20명이후부터는 한명당 1500 추가


- **포인트**
  - 공통 : 관객 30명 이상부터 1명당 1포인트 적립
  - 희극 : 관객 5명마다 추가 포인트 제공( 소수점 버림 )
  
---

### statement

- 이정도로 코드가 지저분하다고 불평할 필요가없다
  - 이정도 짧은 예 에서 굳이 코드가 지저분하다는 이유로 쪼갤 필요가없다


- 코드를 분석해서 파악한 정보는 휘발성이 높으므로 빠르게 코드에 반영해야한다
  - 아무리 간단한 코드라도 수정하고나면 컴파일, 테스트 후 실수한게 없는지 확인한다
  - ( 조금씩 변경하고, 테스트하는 것이 리팩터링 절차의 핵심이다 )
  

- **코드 작성시 어휘력**
  - 예)  
    - <span style="color:#ffb300">a/an</span> : collection 에 들어있는 객체일 경우, 하나의 객체를 지칭할 경우 앞에 붙이는 습관을 들이자
    - <span style="color:#ffb300">result</span> : 반환하는 값의 변수이름
    - <span style="color:#ffb300">plainText</span> : 읽을 수 있는 텍스트
    - <span style="color:#ffb300">~For</span> : 해당 객체의 값을 key 값으로 등으로 가져올때
    - <span style="color:#ffb300">total</span> : reduce 시 acc 보단 total
    - <span style="color:#ffb300">enrich</span> : 해당 객체의 내부 프로퍼티를 추가하거나 채우는등, 내부 프로퍼티를 변경할때
    - <span style="color:#ffb300">transform</span> : 해당 객체의 형태자체가 변경될때


- 매개변수의 역할이 뚜렷하지 않을때는 부정관사를 붙이는 습관<span style="color:#ffb300">( a / an )</span>을 들이자


- 진짜 제일 중요한거는<span style="color:#ffb300"> 읽기 쉬워야한다</span>


- 리팩터링 과정에서 성능이 떨어졌다면, 리팩터링 후 성능을 개선하면 된다
  - 따라서, 리팩터링으로 인해 성능이 떨어진다면 <span style="color:#ffb300">일단 무시한다.</span>

- 흐름을 제어하는 로직을 위해 내부 로컬 function 여러개를 빼내는것에 망설이지말자


- 가변 데이터( mutable )는 상한다. 불변 데이터( immutable )는 데이터의 상태변화를 추적하기 쉽다


- <span style="color:#ffb300">계산 처리와 데이터 처리를 나누자</span>
  - 계산처리는 데이터 구조를 조합하거나 다른곳에 할당하는등
  - 함수형프로그라밍 계산처리( 시간에 관계없는 처리 )
  - 이게 말처럼 쉽지가 아늠... ㅠㅠ

- <span style="color:#ffb300">중요한 것은 데이터 처리다.</span> 화면 변경은 데이터 처리 후 그냥 처리해도 읽기 쉽다


- 각각 코드를 구성하는 로직을 모듈화하면, 코드들의 동작과정을 파악하기 쉬워진다
  - 간결함 보다 <span style="color:#ffb300">명료함이 소프트웨어의 정수이다</span>
  - <span style="color:#ffb300">모듈화</span> 덕분에 계산 코드를 중복하지 않아도 HTML 버전 코드를 생산할 수 있다

- <span style="color:#ffb300">조건문</span>이 있으면 새로운 클래스로 빼서, 아예 <span style="color:#ffb300">다형성으로 처리</span>하는게 좋을 가능성이 높다

- **createStatementData** 함수 자체가 calculator 객체를 반환하게 하는 것도 방법이다
---

현재 프로그람이 새로운 기능을 추가하기 편한 구조가 아니라면,
<span style="color:#ffb300"> 먼저 기능을 추가하기 쉬운 형태로 리팩터링 </span> 하고 나서 원하는 기능을 추가한다

---

컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. <span style="color:#ffb300"> 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자다</span>

---

컴파일 - 테스트 - 커밋 원칙은 절대로 간과해서는 안된다.

---

좋은 코드를 가늠하는 확실한 방법은 <span style="color:#ffb300"> '얼마나 수정하기 쉬운가'</span> 이다

---

### 핵심 정리

1. **테스트 코드 작성**
  - <span style="color:#ffb300">리팩터링하기전에 제대로된 테스트부터 마련한다.</span> 테스트는 반드시 자가진단하도록 맨든다 
  - <span style="color:#ffb300">리팩터링은 프로그람 수정을 작은 단계로 나눠 진행한다</span> 중간에 실수하더라도 버그를 쉽게 찾을 수 있다
2. **이름짓기**
  - 이름 짓기는 중요하면서도 쉽지 않은 작업임.
  - 처음에는 당장에 떠오르는 최선의 이름을 짓다가, <span style="color:#ffb300">코드를 2번이상 읽으면 보통 적합한 이름이 떠오른다</span>
3. **단계나누기**
  - 리팩터링 지점마다 단계를 나누고, 각 단계마다 컴파일-테스트 후 로컬 저장소에 커밋하면 복잡한 코드의 테스트도 성공한다
  - 예) 
    - 반복문 쪼개기
    - 문장 슬라이드하기
    - **함수 추출하기**
    - **변수 인라인하기**
    - **함수 옮기기**
    - 반복문을 파이프라인으로 바꾸기
    - 함수 선언 바꾸기
    - 타입 코드를 서브클래스로 바꾸기
    - 생성자를 팩터리 함수로 바꾸기
    - **조건부 로직을 다형성으로 바꾸기**
  - 기본형 : 크게 중첩함수로 나누고, 계산, 액션, 데이터를 분리, 조건문을 다형성으로 처리
4. **데이터 만들기**
  - 중요한 것은 로직의 결괏값들을 전부 데이터로 만들어야한다!!!( 재사용하기 편해짐 )

5. **다형성**
  - 조건부 로직이 길어지거나 추가될 가능성이 높다면 다형성으로 처리하는 것이 좋다