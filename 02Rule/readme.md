## 리팩터링 원칙( Refactoring Rule )

### 리팩터링 정의

---
#### 명사형 리팩터링

**리팩터링** : [ 명사 ] 소프트웨어의 겉보기 동작은 그대로 <span style="color:#ffb300">유지한채</span> ,
코드를 <span style="color:#ffb300">이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법</span>

---

#### 동사형 리팩터링

**리팩터링( 하다 )** : [ 명사 ] 소프트웨어의 겉보기 동작은 그대로 <span style="color:#ffb300">유지한채</span> ,
여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

---

- 리팩터링은 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이런 단계들을 연결하여 큰 변화를 만들어내는 일이다.
- 따라서, 리팩터링 하는 동안에는 코드가 항상 정상 작동하게 된다
  - **리팩터링하다가 코드가 깨져서 며칠이나 고생했다** 라고 한다면 이것은 리팩터링 한 것이 아니다.
- 리팩터링의 목적은 코드를 이해하기 쉽고 수정하기 쉽게 맨드는 것!


- 프로그람을 개발할때는, **기능 추가** 인가, **리팩터링** 인가를 명확하게 구분해야한다
  - 현재 내가하고 있는 작업이 무엇인지를 명확하게 해야한다

---

### 리팩터링의 이유

- <span style="color:#ffb300">**리팩터링하면 소프트웨어의 설계가 좋아진다**</span>
  - 아키텍쳐를 충분히 이해하지 못한채 단기 목표를 위해 코드를 작성하다보면 기반 구조가 무너지기 쉽다
  - 코드만으로 설계를 파악하기 어려워질수록 설계를 유지하기 어렵고, 부패하기 시작한다
- <span style="color:#ffb300">**리팩터링하면 소프트웨어를 이해하기 쉬워진다**</span>
  - 코드의 목적이 잘 드러나게, 의도를 명확하게 전달할 수 있도록 리팩터링하면, 코드를 기억할 필요가 없다
- <span style="color:#ffb300">**리팩터링하면 버그를 쉽게 찾을 수 있다**</span>
  - 프로그람 구조를 다듬으면 ~~할것이다 가정하는 점들이 분명히 드러난다
- <span style="color:#ffb300">**리팩터링하면 프로그라밍 속도를 높일 수 있다**</span>
  - 기능이 누적될 수록 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 찾을 수 있다
  - 모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다
  - 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져 빠르게 개발할 수 있는 상태를 오래 지속할 수 있다

---

### 언제 리팩터링해야 할까?

- <span style="color:#ffb300">**리팩터링 가이드**</span>
  1. _처음에는 그냥 한다_
  2. _비슷한 일을 두 번째로 하게 되면( 중복이 생겼다는 사실에 당황스럽지만 ), 일단 계속 진행한다_
  3. <span style="color:#ffb300">_비슷한 일을 세 번째 하게 되면 리팩터링 한다_</span>
- 스트라이크 세번이면 리팩터링하라


- **준비를 위한 리팩터링** : <span style="color:#ffb300">기능을 쉽게 추가하게 맨들기</span>
  - 리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전
  - 현재 코드를 살펴보며, 구조를 바꾸면 다른 작업하기 쉬워질만한 부분을 찾는다
  - 새로운 기능을 추가히전에 기존 코드를 수정해야하는지 검토 후 추가한다
  

- **이해를 위한 리팩터링** : <span style="color:#ffb300">코드를 이해하기 쉽게 맨들기</span>
  - 코드를 수정하려면 그 코드가 하는 일을 파악해야한다
  - 그 코드를 수정할때는, 그 코드의 의도가 명확하게 드러나도록 수정한다
  - 함수 이름이 길다면 여러 함수로 쪼개 분리하거나, 적절한 이름을 붙여준다
  

- <span style="color:#ffb300">**쓰레기 줍기 리팩터링**</span>
  - 로직이 쓸데없이 복잡하거나, 같은일을 하는 함수가 많은등 쓰레기가 많을 경우,
  - 간단히 고칠 수 있는 것들은 즉시 고치고, 시간이 걸리는 일들은 짧은 메모만 남기고 다른일을 처리한다
  - 이것을 쓰레기 줍기( Litter-Pickup Refactoring )라고 부른다


- <span style="color:#ffb300">**계획된 리팩터링과 수시로하는 리팩터링**</span>
  - 리팩터링 일정을 따로 잡는 것이 아닌, 일을 하는 중에 처리한다
  - 보기 싫은 코드를 발견하면 리팩터링하자. <span style="color:#ffb300"> 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다 </span>
  - 무언가 수정하려 할때는 먼저 <span style="color:#ffb300"> 수정하기 쉽게 정돈하고( 만만치 않을 수 있다 ) </span> 그런 다음 쉽게 수정하자
  - 새 기능을 추가하기 쉽도록 코드를 수정하는 것이 기능을 빠르게 추가하는 길이다
  - 리팩터링 작업은 드러나지 않게, 기회가 될때마다 해야한다
  

- <span style="color:#ffb300">**오래 걸리는 리팩터링**</span>
  - 리팩터링은 대부분 몇 분안에 끝난다. 길어야 몇 시간 정도다. 그러나 대규모 리팩터링도 있다
  - 리팩터링에 매달리는게 아니라, 주어진 문제를 몇 주에 걸쳐 조금씩 해결해나갈때 효과적이다


- <span style="color:#ffb300">**코드 리뷰에 리팩터링 활용하기**</span>
  - 리팩터링은 다른이의 코드를 리뷰하는데 도움이된다
    - 새로운 아이디어가 떠오르면, 리팩터링하여 구현해 넣을 수 있는지 살펴본다
    - 머리로 상상하는게 아닌, 눈으로 직접 확인하는 것이다
    - 새로운 기능을 빠르게 구현하는것. 가장 빠른 방법은 <span style="color:#ffb300">리팩터링</span>이다
    

- <span style="color:#ffb300">**리팩터링하지 말아야 할 때**</span>
  - 지저분한 코드를 발견해도 굳이 수정할 필요가 없다면 리팩터링하지 않는다
  - <span style="color:#ffb300">내부 동작을 이해해야할 시점에</span> 리팩터링해야 효과를 제대로 볼 수 있다
  - 리팩터링하는 것 보다, 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다
  - ( 그러나 이런 판단을 내리기는 수많은 경험과 판단력이 필요하다 )
  
---

### 리팩터링 시 고려할 문제


- <span style="color:#ffb300">**새 기능 개발 속도 저하**</span>
  - 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다
    - 준비를 위한 리팩터링을 하며, 새 기능을 구현하기 편해지겠다 싶은 리팩터링은 주저하지 않고 리팩터링부터 한다
    - 반면, 그리 불편하지 않다면 리팩터링하지 않는다
    - 리팩터링의 본질은 <span style="color:#ffb300">코드베이스를 예쁘게 꾸미는데 있지 않다. 오로지 경제적인 이유로 하는 것이다. </span>


- <span style="color:#ffb300">**코드 소유권**</span>
  - 리팩터링하다보면, 모듈의 내부 뿐아니라, 시스템의 다른부분과 연동하는 방식에도 영향을 주는 경우가 많다
  - 함수를 호출하는 코드를 전부찾을 수 없거나 , 호출하는 코드의 소유자가 다른팀일 경우 등
  - 코드 소유권이 나뉘어 있다면 <span style="color:#ffb300">**함수 이름 바꾸기**</span>를 적용하고, 기존함수를 유지하되, 새로운 함수를 호출하도록 수정한다


- <span style="color:#ffb300">**테스팅**</span>
  - 리팩터링의 특성은 프로그람의 겉보기 동작은 똑같이 유지된다는 것이다
  - 단계별 변경 폭이 작기 때문에, 오류의 원인이 될 코드의 범위가 넓지 않다
  - 리팩터링에 믿음성이 생기기 위해서는 테스트 코드를 작성해야 한다
  - <span style="color:#ffb300">테스트를 염두해두고 설계한 시스템만 쉽게 테스트할 수 있다</span>


- <span style="color:#ffb300">**레거시 코드**</span>
  - 레거시 코드는 대체로 복잡하고 테스트도 제대로 갖춰지지 않은 것이 많다
  - 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하기는 어렵다
  - 서로 관련된 부분끼리 나눠서 하나씩 공략하는 것이 핵심이다


- <span style="color:#ffb300">**데이터베이스**</span>
  - 진화형 데이터베이스 설계( evolutionary database design )와 데이터베이스 리팩터링 기법으로 리팩터링하라 
    - 커다란 변경들을 쉽게 조합하고 다룰 수 있는 마이그레이션 스크립트 작성
    - 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 마이그레이션 스크립트로 처리하도록 통합
  - 이 리팩터링도 다른 리팩터링과 마찬가지로 전체 변경 과정을 작고 독립된 단계들로 쪼개는 것이 핵심이다
    - 예) 필드이름 변경
      - 첫 번째 커밋 : 새로운 데이터베이스 필드 추가
      - 두 번째 커밋 : 기존 필드와 새 필드를 동시에 업데이트 하도록 변경
      - 다음 커밋 : 기존 필드를 읽는 클라이언트들을 새 필드를 사용하는 버전으로 교체
      - 마지막 커밋 : 예전 필드 삭제
    - 병렬 수정( parallel change ), 팽창-수축( expand-contract )의 예이다
    
---

### 리팩터링, 아키텍처, 애그니( YAGNI )


탄탄한 테스트가 뒷받침해주지 못한 코드는 리팩터링하기 더더욱 어렵다


유연성 매커니즘을 추가할 때는 확신이 들때만 추가해야 한다


- 유연성 매커니즘( flexibility mechanism )
  - 범용적으로 사용할 수 있도록 함수에 다양한 매개변수 추가하는 기법
    - 당장의 쓰임에 비해 함수가 너무 복잡해진다
    - 깜빡잊은 매개변수가 있다면 앞에서 추가한 매개변수 때문에 새로 추가하기 더 어려워진다
  - 따라서, <span style="color:#ffb300">유연성 매커니즘이 오히려 변화에 대응하는 능력을 떨어뜨릴 때가 대부분이다</span>


- 리팩터링
  - 어느부분에 유연성이 필요할 것이라고 추측하지 않고, 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다
  - 진행하면서 아키텍처도 사용자의 요구사항에 맞게 리팩터링
  - 소프트웨어의 복잡도에 주장을 주지않는 매커니즘은 원하는대로 추가하지만, <span style="color:#ffb300"> 복잡도를 높일 수 있는 유연성 매커니즘은 반드시 검증을 거친 후 추가 </span>한다
    - 매개변수를 추가해야할 시점이오면 <span style="color:#ffb300"> 함수 매개변수화하기 </span>로 해결한다

---

### <span style="color:#ffb300">예상되는 변경을 미리 반영하는 리팩터링</span>을 미루면 어떻게 될지 계산해보고, <span style="color:#ffb300">해야겠다는 확신</span>이 들면 유연성 매커니즘을 추가하는 것이다

---

- 리팩터링 설계 방식을
  - 간결한 설계( simple design ), 점진적 설계( incremental design ), YAGNI( 애그니 )등으로 부른다
- 진화형 아키텍처( evolutionary architecture )
  - YAGNI 를 받아들인다고 해서, 아키텍처에 대해 소홀해서는 안되고, 리팩터링으로는 변경하기 어려워 미리 생각해두면 시간이 절약되는 경우도 있다
  - 그러나, <span style="color:#ffb300">나중에 문제를 깊이 이해하게 되었을 때</span> 처리하는 쪽이 훨씬 좋을 수 있다
  - 아키텍처 관련 결정을 시간을 두고 반복해 내릴 수 있다는 장점을 활용하는 패턴과 실천법을 추구

---

### 리팩터링과 소프트웨어 개발 프로세스

- <span style="color:#ffb300">**테스트 주도 개발( TDD )**</span>
  - 자가 테스트 코드와 리팩터링하는 기법
    - 애자일을 제대로 적용하려면 리팩터링에 대한 팀의 역량과 열정이 뒷받침되어 프로세스 전반에 리팩터링이 스며들도록 해야한다


- <span style="color:#ffb300">**자가 테스트 코드**</span>
  - 리팩터링의 첫번째, 즉, 프로그라밍 중 발생한 오류를 확실히 걸러내는 테스트를 수행할 수 있어야 한다
    - 테스트는 리팩터링에 중요한 토대이다


- <span style="color:#ffb300">**지속적 통합**</span>
  - 팀원 각자가 수행한 리팩터링 결과를 동료와 빠르게 공유한다
  - 조만간 삭제될 인터페이스를 이용하여 기능을 추가하는 일을 방지할 수 있다
  

- 이 세가지 기법( 테스트코드 , 지속적 통합 , 리팩터링 )은 강력한 상승효과를 발휘한다
  - 수많은 유연성 메커니즘을 갖춘 시스템보다, <span style="color:#ffb300">단순한 시스템이 변경하기 훨씬 쉽다</span>

---

### 리팩터링과 성능

- <span style="color:#ffb300">**직관적인 설계 vs 성능**</span>
  - 리팩터링하면 소프트웨어가 느려질 수도 있는 건 사실이다
  - 하지만, 성능을 튜닝하기는 더 쉬워진다
  - 소프트웨어를 빠르게 맨드는 비결은 먼저 <span style="color:#ffb300">튜닝하기 쉽게 맨들고나서 </span> 원하는 속도가 나오게끔 튜닝하는 것이다
  

- <span style="color:#ffb300">**성능 최적화**</span>
  - 프로파일러로 프로그람을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아내고, 성능에 영향을 주는 작은 부분들을 찾아낸다
  - 리팩터링처럼 최적화를 위한 수정도 작은 단계로 나눠서 진행한다


- 프로그람을 잘 리팩터링 해두면 최적화에 도움이 된다
  1. 성능 튜닝에 투입할 시간을 벌 수 있다
    - 리팩터링이 잘 되어 있다면 기능추가가 빨리 끝나, 성능에 집중할 시간을 벌 수 있다
  2. 리팩터링이 잘 되어 있는 프로그람은 성능을 세밀히 분석할 수 있다
    - 프로파일러가 지정해주는 코드의 범위가 더 좁아지고, 튜닝하기 쉬워진다
    - 코드가 깔끔해져, 개선안들이 더 잘 떠오르게 된다

리팩터링은 성능 좋은 소프트웨어를 맨드는데 기여한다. 단기적으로 보면 성능이 느려질 수도 있지만,
<span style="color:#ffb300">최적화 단계에서 코드를 튜닝하기 더욱 쉬워져</span> 더 빠른 소프트웨어를 얻을 수 있다

---

### 리팩터링의 유래

- 실력있는 개발자는 항상 자신의 코드를 정리하는데 어느정도 시간을 할애한다
  - 처음부터 깔끔하게 작성하는 경우는 없다는 것을 경험을 통해 알기 때문이다
  - 리팩터링은 여기서 한걸음 더 나아간다

---

### 리팩터링 자동화

- 직접 코드의 텍스트를 조작하는 '찾아 바꾸기' 방식은 신뢰해서는 안된다
- 자동 리팩터링을 구현하려면 코드를 텍스트 상태가 아닌, <span style="color:#ffb300">구문 트리( syntax tree )</span>로 해석해서 다뤄야 한다
- 정적 언어에서 자동 리팩터링기법이 극대화된다( 같은 이름의 메서드라도 어디에서 사용하는지 추적할 수 있기 때문 )